<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [js函数作用域](#js%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F)
- [函数柯里化的应用 add(1)(2)(3)](#%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%E7%9A%84%E5%BA%94%E7%94%A8-add123)
- [回调函数promisify化](#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0promisify%E5%8C%96)
- [获取10-100之间不重复的10个数字](#%E8%8E%B7%E5%8F%9610-100%E4%B9%8B%E9%97%B4%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%8410%E4%B8%AA%E6%95%B0%E5%AD%97)
- [数组乱序](#%E6%95%B0%E7%BB%84%E4%B9%B1%E5%BA%8F)
- [将多维数组转化为一维数组，这是一种方法](#%E5%B0%86%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BF%99%E6%98%AF%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95)
- [浅拷贝和深拷贝](#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D)
- [解析 url 同时返回一个方法，如果找不到这个字符串，返回undefined，如果是一个，返回true，有多个返回数组](#%E8%A7%A3%E6%9E%90-url-%E5%90%8C%E6%97%B6%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E5%A6%82%E6%9E%9C%E6%89%BE%E4%B8%8D%E5%88%B0%E8%BF%99%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%94%E5%9B%9Eundefined%E5%A6%82%E6%9E%9C%E6%98%AF%E4%B8%80%E4%B8%AA%E8%BF%94%E5%9B%9Etrue%E6%9C%89%E5%A4%9A%E4%B8%AA%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84)
- [node下没有window对象，需要在浏览器执行](#node%E4%B8%8B%E6%B2%A1%E6%9C%89window%E5%AF%B9%E8%B1%A1%E9%9C%80%E8%A6%81%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A7%E8%A1%8C)
- [回文字符串](#%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2)
- [闭包](#%E9%97%AD%E5%8C%85)
- [call,apply,bind](#callapplybind)
- [节流和防抖](#%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96)
- [promise简单版](#promise%E7%AE%80%E5%8D%95%E7%89%88)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

##  js函数作用域
```js
// js函数作用域
var values1 = 0;
var values2 = 0;
var values3 = 0;

for (var i = 1; i <= 3; i++) {
    var i2 = i;
    (function () {
        var i3 = i;
        setTimeout(function () {
            values1 += i;
            values2 += i2;
            values3 += i3;
        });
    })()
}

setTimeout(function () {
    console.log(`${values1},${values2},${values3}`)
}, 100)

/**
* 解析：12,9.6
*   第一个是12是因为i为4的时候才停止循环
*   第二个是9是因为i2最终为3
*   第三个是6是因为闭包函数执行之后会有自己的执行栈，栈中的值都是运算完的结果
*/

```


##  函数柯里化的应用 add(1)(2)(3)
```js
// 函数柯里化的应用 add(1)(2)(3)
const add = (...params) => {
  // 缓存第一次的参数
  const _args = params;

  const tmp = function (...addParams) {
      // 合并之后的参数,并且返回当前函数，作为下个参数的函数
      _args.push(...addParams);
      return tmp;
  };

  // log的时候会执行这个方法 
  tmp.toString = function () {
      // 返回全部的值
      return _args.reduce((a, b) => a + b);
  };
  return tmp;
}
console.log(add(1, 2)(2)(3, 6));

/** 
 * 思路：
 *  首先获取第一次add的结果
 *  然后返回一个函数
 *      这个函数的功能是获取参数，然后将参数相加,然后返回当前函数
 *      但是这个时候并不能满足最后返回的值是和，所以修改这个函数的toString方法，这个方法返回sum。
 *  注：在node返回不对
 */
```



##  回调函数promisify化
```js
function promisify(f) {
    return function(...params) {
        var args = params;

        return new Promise(function(resolve, reject) {
            args.push(function(err, data) {
                if (err) reject(err);
                else resolve(data);
            });
            f.apply(null, args);
        });        
    }
}

promisify('./data.json', 'utf-8')
.then(function(data) {
    console.log(data);
})
.catch(function(err) {
    console.err(err);
})

/**
* 解析：
*  第一个参数是函数，缓存起来
*  返回一个函数
*    获取所有的参数
*    将回调函数作为最后一个参数加入参数中
*    第一个函数执行它
*  这个和函数柯里化非常像，基本一致
*/

```

##  获取10-100之间不重复的10个数字
```js
// 获取10-100之间不重复的10个数字
(function() {
    const set = new Set();
    while (set.size < 10) {
        const value = parseInt(Math.random() * 90 + 10);
        set.add(value);
    }
    console.log('10个非重复数字：' + set);
})();
/**
* 思路：
*   数组存储数据，通过random函数获取指定结果，indexof判断是否已经包含这个数字
*/
```

##  数组乱序
```js
// 数组乱序
(function () {
    let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    arr.sort(() => {
        return Math.random() - 0.5;
    });
    console.log(arr);
}
());
```

##   将多维数组转化为一维数组，这是一种方法
```js
// 将多维数组转化为一维数组  有好多种方法，这个我觉得挺好的
let arr = [1, [2, [[3, 4], 5], 6]];

function parse (arr) {
    const tempArr = [];
    for(let item of arr) {
        if(Array.isArray(item)) {
            tempArr.push(...parse(item));
        }else {
            tempArr.push(item);
        }
    } 
    return tempArr;
}

console.log(parse(arr));
/**
* 
* 实现有好多种方法，但是核心思路就是：遍历array,如果某一项为数组，则递归调用遍历函数
*/
```

## 浅拷贝和深拷贝
```ts
/**
 * 浅拷贝
 * 1.assign
 * 2.扩展运算符
 */

let obj2 = {a:1,b:2};
let obj3 = {...obj2};
console.log(obj3);

let arr2 = [1,2];
let arr3 = [...arr2];
console.log(arr3);


/***
 * 深拷贝
 *
 *  思路：
 *      如果是基本类型，就直接赋值，否则
 *          对象
 *              遍历对象的属性，返回
 *          数组
 *              遍历对象的数组，返回
 */


function deepClone(data) {
  if (typeof data !== 'object') {
    return data;
  } else if (Array.isArray(data)) { // 是数组
    const arr = [];
    for (const item of data) {
      arr.push(deepClone(item));
    }
    return arr;
  } else { // 是对象
    const obj = {};
    for (const item in data) {
      obj[item] = deepClone(data[item]);
    }
    return obj;
  }
}

let o1 = deepClone({name:'1',age:'3',arr:[1,2,3,{'haha':'haha'}]});
console.log(JSON.stringify(o1));
 ```


##  解析 url 同时返回一个方法，如果找不到这个字符串，返回undefined，如果是一个，返回true，有多个返回数组
```js
/**
 * 解析 url 同时返回一个方法，如果找不到这个字符串，返回undefined，如果是一个，返回true，有多个返回数组
 * @param url
 */
function urlParse(url) {
    let obj = {};
    let reg = /[?&][^?&]+=[^?&]+/g;
    let arr = url.match(reg);
    if (arr) {
        arr.forEach(function (item) {
            item = item.substring(1).split('=');
            let key = decodeURIComponent(item[0]);
            let value = decodeURIComponent(item[1]);
            if (!obj[key]) {
                obj[key] = value;
            } else {
                if (Array.isArray(obj[key])) {
                    obj[key].push(value);
                } else {
                    obj[key] = [obj[key], value];
                }
            }
        });
    }
    return function (key) {
        return obj[key];
    }
}

var getPara = urlParse('https://twotiger.com/aa?name=100&age=200&aa=300&aa=400&aa=500');
console.log(getPara('name'));
console.log(getPara('aa'));
console.log(getPara('bb'));
```

##  node下没有window对象，需要在浏览器执行
```js
// node下没有window对象，需要在浏览器执行
window.name = 'world';

let obj = {
    name: 'hello',
    alias: this.name,
    getInfo: function () {
        console.log(this.name);
        console.log(this.alias);
    },
    agetInfo: () => {
        console.log(this.name);
        console.log(this.alias);
    }
};

obj.getInfo();
obj.agetInfo();
/**
* 
* 首先对象没有作用域
*   this.alias在obj对象生成的时候已经被解析了，值为world
*   然后箭头函数的动态作用域显然属于全局的，因为没有函数作用域存在，肯定是全局作用域
*   hello  world  world  undefined
*/

/*function haha() {
    var name = 'aaa';
    let obj = {
        name: 'hello',
        alias: this.name,
        getInfo: function () {
            console.log(this.name);
            console.log(this.alias);
        },
        agetInfo: () => {
            console.log(this.name);
            console.log(this.alias);
        }
    };

    obj.getInfo();
    obj.agetInfo();
}*/
```


##  回文字符串
```js
function f(str) {
    let arr = str.split('');
    let stack = [];
    arr.forEach(function (item) {
        if (stack[stack.length - 1] === item) {
            stack.pop();
        }
        else {
            stack.push(item);
        }
    });
    console.log('当前字符串是', str, '', "\u6570\u7EC4\u957F\u5EA6\u4E3A\uFF1A" + stack.length);
    return stack.length < 1;
};
f('1234554321');
f('122112212112');
f('1234');
```

##  闭包
```js
//  循环中使⽤闭包解决 `var` 定义函数的问题
for (var i = 1; i <= 5; i++) {
    setTimeout(function timer() {
        console.log(i)
    }, i * 1000)
}

// 第一种：使用闭包函数
for (var i = 1; i <= 5; i++) {
    (function (j) {
        setTimeout(function timer() {
            console.log(j)
        }, j * 1000)
    })(i);
}

// 第二种：使用setTimeout第三个参数为函数参数
for (var i = 1; i <= 5; i++) {
    setTimeout(
        function timer(j) {
            console.log(j)
        }, i * 1000, i)
}

// 第三种：使用let
for (let i = 1; i <= 5; i++) {
    setTimeout(function timer() {
        console.log(i)
    }, i * 1000)
}
```

 ##  call,apply,bind
```js
 /**
 *
 * 思路：
 *  this代表函数
 *  参数中第一个是被执行的对象
 *  剩下的参数是函数的参数
 *  拼接成新的函数就ok了
 *
 * @param context
 * @returns {*}
 */

Function.prototype.myCall = function (context,...args) {
    if (typeof this !== 'function') {
        throw new TypeError('Error')
    }
    context = context || window
    context.fn = this // context为函数的
    const result = context.fn(...args)
    delete context.fn
    return result
};

/**
 *
 * 思路：
 *  和call的区别就是第二个参数是数组
 *
 * @param context
 * @returns {*}
 */
Function.prototype.myApply = function (context,args) {
    if (typeof this !== 'function') {
        throw new TypeError('Error')
    }
    context = context || window
    context.fn = this
    let result
    // 处理参数和 call 有区别
    if (args) {
        result = context.fn(...args)
    } else {
        result = context.fn()
    }
    delete context.fn
    return result
}

/**
 *
 * 思路：
 *  返回一个函数，这个函数内部是原来对象.call（函数参数）
 *  如果有预先设置的参数，将原先的参数和新的参数拼接传入
 *
 *
 * @param context
 * @returns {F}
 */
Function.prototype.myBind = function (context,...args) {
    if (typeof this !== 'function') {
        throw new TypeError('Error')
    }
    const _this = this
    // 返回一个函数
    return function F(...params) {
        // 因为返回了一个函数，我们可以 new F()，所以需要判断
        if (this instanceof F) {
            return new _this(...args, ...arguments)
        }
        return _this.apply(context, args.concat(...params))
    }
}
 ```

 ##  节流和防抖
```js
/**
 *
 * 节流
 * 指的是一段时间内，连续触发n次事件，只执行一次
 * 场景：监听scroll，mouseover事件的时候，我们一段时间内只需要执行一次就行
 * 思路：
 *  使用闭包保存一个时间，每次点击判断这个时间是否大于上次保存的时间，如果大于的话更新时间并且执行函数
 */
// func是用户传入需要防抖的函数
// wait是等待时间
const throttle = (func, wait = 50) => {
    // 上一次执行该函数的时间
    let lastTime = 0;
    return function (...args) {
        // 当前时间
        let now = +new Date();
        // 将当前时间和上一次执行函数时间对比
        // 如果差值大于设置的等待时间就执行函数
        if (now - lastTime > wait) {
            func.apply(this, args)
            lastTime = now
        }
    }
};

setInterval(
    throttle(() => {
        console.log(1)
    }, 500),
    1
)


/**
 *
 * 防抖
 * 指的是触发事件后在n秒后再执行，如果n秒内又触发了事件，则重新计算执行时间。
 * 场景：文本框输入校验，我们只在最后一次修改触发校验
 *
 * 闭包缓存定时器，返回函数，如果函数被执行，则清除定时器，设置一个新的定时器
 *  相当于在指定时间过后还没有被清除就会执行
 *
 */

// func是用户传入需要防抖的函数
// wait是等待时间
const debounce = (func, wait = 50) => {
    // 缓存一个定时器id
    let timer = 0
    // 这里返回的函数是每次用户实际调用的防抖函数
    // 如果已经设定过定时器了就清空上一次的定时器
    // 开始一个新的定时器，延迟执行用户传入的方法
    return function (...args) {
        if (timer) clearTimeout(timer)
        timer = setTimeout(() => {
            func.apply(this, args)
        }, wait)
    }
};
 ```

##  promise简单版
```js
const PENDING = 'pending';
const RESOLVED = 'resolved';
const REJECTED = 'rejected';

function MyPromise(fn) {
    const that = this;
    that.state = PENDING;
    that.value = null;
    that.resolvedCallbacks = [];
    that.rejectedCallbacks = [];

    // 首先我们创建了三个常量用于表示状态，对于经常使用的一些值都应该通过常量来管理，便于开发及后期维护
    // 在函数体内部首先创建了常量 that，因为代码可能会异步执行，用于获取正确的 this 对象
    // 一开始 Promise 的状态应该是 pending
    // value 变量用于保存 resolve 或者 reject 中传入的值
    // resolvedCallbacks 和 rejectedCallbacks 用于保存 then 中的回调，因为当执行完 Promise 时状态可能还是等待中，这时候应该把 then 中的回调保存起来用于状态改变时使用

    function resolve(value) {
        if (that.state === PENDING) {
            that.state = RESOLVED;
            that.value = value;
            that.resolvedCallbacks.map(cb => cb(that.value))
        }
    }

    function reject(value) {
        if (that.state === PENDING) {
            that.state = REJECTED;
            that.value = value;
            that.rejectedCallbacks.map(cb => cb(that.value))
        }
    }

    // 这两个函数代码类似，就一起解析了
    //
    // 首先两个函数都得判断当前状态是否为等待中，因为规范规定只有等待态才可以改变状态
    // 将当前状态更改为对应状态，并且将传入的值赋值给 value
    // 遍历回调数组并执行

    try {
        fn(resolve, reject)
    } catch (e) {
        reject(e)
    }

    // 实现很简单，执行传入的参数并且将之前两个函数当做参数传进去
    // 要注意的是，可能执行函数过程中会遇到错误，需要捕获错误并且执行 reject 函数
}

MyPromise.prototype.then = function (onFulfilled, onRejected) {
    const that = this;
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v
    onRejected =
        typeof onRejected === 'function'
            ? onRejected
            : r => {
                throw r
            };
    if (that.state === PENDING) {
        that.resolvedCallbacks.push(onFulfilled);
        that.rejectedCallbacks.push(onRejected);
    }
    if (that.state === RESOLVED) {
        onFulfilled(that.value)
    }
    if (that.state === REJECTED) {
        onRejected(that.value)
    }
};

/**
 * promise.all原理
 *  利用闭包函数存储promise的length，
 *      每次执行成功了，then方法中将promise存储起来，然后当存储的promise结果和请求的数量一致的时候返回promise
 */

/**
 * Promise.all Promise进行并行处理
 * 参数: promise对象组成的数组作为参数
 * 返回值: 返回一个Promise实例
 * 当这个数组里的所有promise对象全部变为resolve状态的时候，才会resolve。
 */
Promise.all = function (promises) {
    return new Promise((resolve, reject) => {
        let done = gen(promises.length, resolve);
        promises.forEach((promise, index) => {
            promise.then((value) => {
                done(index, value)
            }, reject)
        })
    })
};

function gen(length, resolve) {
    let count = 0;
    let values = [];
    return function (i, value) {
        values[i] = value;
        if (++count === length) {
            console.log(values);
            resolve(values);
        }
    }
}

```